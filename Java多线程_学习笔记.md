# 多线程
[static方法加锁](http://www.cnblogs.com/shipengzhi/articles/2223100.html)
[锁的概念](http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html)
## 概念
###1.进程是程序（任务）执行过程，
* 持有资源（共享内存，共享文件）和线程。
* 进程是动态性的
###2、线程是系统中最小的执行单元。
* 同一进程中有多个线程，线程共享进程的资源。
* 一个进程中包含了多个线程。
###3.线程之间需要相互通信，
* 同步（线程之间的合作关系），
* 互斥（线程之间的竞争关系）。
**以生活中一个班级为例**

## 基础
###1：创建线程的方法有两种<br>
1. ：继承Thread类<br>
1. ：实现Runnable接口<br>
###2：线程中的方法比较有特点.
比如：启动(start)、休眠(sleep)、停止等，多个线程是交互执行的（CPU在某个时刻

-----
>只能执行一个线程，当一个线程休眠了或者执行完毕了，另一个线程才能占用CPU来执行），因为这是CPU的结构来决的，在某个时刻CPU只能执行一个线程，不过速度相当快，对于人来讲可以认为是并行执行的。
<br>
<br>
>在一个.java文件中，可以有多个类，但只能有一个public类。

-----------
### 两种创建方法的区别
这两种创建线程的方法本身没有什么不同，一个是实现Runnable接口，一个是继承Thread类。而使用实现Runnable接口这种方法：
###如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。

1. 可以避免Java的单继承的特性带来的局限性；
2. 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码及数据有效分离，较好地体现了面向对象的设计思想。开发中大多情况下都使用实现Runnable接口这种方法创建线程。

实现Runnable接口创建的线程最终还是要通过将自身实例作为参数传递给Thread然后执行
语法：`Thread Actress = new Thread(Runnable target, String name)`
例如：`Thread actressThread=new Thread(new Actress(),"Ms.Runnable");
actressThread.start();`
## 方法详解

1. join是为了让舞台线程最后停止，如果不用有可能舞台线程结束，军队线程还未停止。就好比 ，导演喊停，演员还在演。可以在join后面加入测试语句，System .out.println("舞台结束") 然后去掉或者保留join观察效果
2. volatile关键字保证了线程可以正确的读取其他线程写入的值，如果不写成Volatile，由于可见性的问题，当前线程有可能不能读到这个值，可加性JMM（java内存模型）happens-before原则，可见性原则
用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值。
3. thread.yield();//让出处理器时间，公平竞争
4. join 方法会让所有的线程等待调用join方法的线程。

##正确停止线程的方法是：<br>
**使用退出标志，而非使用线程的stop()方法。**<br>
使用退出标志停止线程执行的方式的好处在于：<br>

1. 可以使线程执行完对应的操作后，因不符合继续执行的条件而停止
2. 我们可以做一些线程执行结束后的清理工作
3. 使线程的结束执行看起来是有次序的，而非戛然而止

##错误结束线程的方法
* interrupt()方法不是一个使线程正确退出的方式，线程中任何的阻塞都会导致interrupt（）方法设置好的isInterrupted()为true的状态被清除。而且，如果用这种方式停止线程的话，那其本质上其实还是设置旗标的方式罢了。<br>
* stop方法，因为stop方法是一个强制关闭的方法，是的有些工作和资源还没有做完或释放就结束线程。

##争用条件
1、当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted)，这种现象称为争用条件<br>
2、原因是，每个线程在操作数据时，会先将数据初值读【取到自己获得的内存中】，然后在内存中进行运算后，重新赋值到数据。 <br>
3、争用条件：线程1在还【未重新将值赋回去时】，线程1阻塞，线程2开始访问该数据，然后进行了修改，之后被阻塞的线程1再获得资源，而将之前计算的值覆盖掉线程2所修改的值，就出现了数据丢失情况

##互斥与同步
###一、互斥
1、同一时间，只能有一个线程访问数据<br>
###二、同步
1、是一种通信机制，一个线程操作完成后，以某种方式通知其他线程
###三、实现方法
1. 【互斥】构建锁对象（Object objLock)，通过synchronized(lockObj){ //互斥的代码块 }
2. 加锁操作会开销系统资源，降低效率。
3. 在某线程的条件不满足任务时，使用lockObj.wait()对线程进行阻挡，防止其继续竞争CPU资源，滞留在wait set中，等待唤醒,【唤醒后继续完成业务】
4. 【同步】在某一代码正确执行完业务后，通过lockObj.notifyAll()唤醒所有在lockObj对象等待的线程

##
互斥的实现：synchronized（lockObj）;java的语法保证的同一时间，只有一个线程获得lockObj

同步：wait(),notify(),notifyall(),都是属于object类，并不是thread类

wait set 类似于线程的休息室，访问共享数据的代码称为critical section。一个线程获取锁，然后进入临界区 ，发现某些条件不满足，然后调用锁对象上的wait方法，然后线程释放掉锁资源，进入锁对象上的wait set。其他线程可以获取所资源，然后执行，完了以后调用notify，通知锁对象上的等待线程。

Ps：若调用notify();则随机拿出（这随机拿出是内部的算法，无需了解）一条在等待的资源进行准备进入Critical Section；若调用notifyAll();则全部取出进行准备进入Critical Section
##为什么有程序块锁
首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变

量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。


##产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。<br>
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>

##Java多线程进阶
1. Java Memory Mode:JMM描述了java线程如何通过内存进行交互，了解happens-before,synchronized,voliatile & final
2. Locks % Condition：锁机制和等待条件的高层实现 java.util,concurrent.locks
3. 线程安全性：原子性与可见性，死锁等
4. 多线程常用的交互模型
· Producer-Consumer模型
· Read-Write Lock模型
· Future模型
· Worker Thread模型
5. Java5中并发编程工具：java.util.concurrent 包下的
例如：线程池ExcutorService 
Callable&Future 
BlockingQueue
6. 推荐书本：CoreJava(java核心编程) & JavaConcurrency In Practice（誉为：并发圣经）

